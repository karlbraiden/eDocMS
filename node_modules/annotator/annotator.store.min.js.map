{"version":3,"file":"annotator.store.min.js","sources":["../node_modules/browserify/node_modules/browser-pack/_prelude.js","namespace.coffee","plugin/store.coffee"],"names":[],"mappings":";;;;;;;;;;CAAA,SAAA,GAAA,GAAA,gBAAA,SAAA,OAAA,QAAA,QAAA,IAAA,kBAAA,SAAA,OAAA,IAAA,OAAA,OAAA,CAAA,GAAA,EAAA,oBAAA,QAAA,EAAA,OAAA,mBAAA,QAAA,EAAA,OAAA,mBAAA,QAAA,EAAA,KAAA,IAAA,GAAA,CAAA,GAAA,EAAA,YAAA,EAAA,cAAA,EAAA,EAAA,SAAA,EAAA,WAAA,EAAA,MAAA,MAAA,WAAA,MAAA,SAAA,GAAA,EAAA,EAAA,GAAA,QAAA,GAAA,EAAA,GAAA,IAAA,EAAA,GAAA,CAAA,IAAA,EAAA,GAAA,CAAA,GAAA,GAAA,kBAAA,UAAA,OAAA,KAAA,GAAA,EAAA,MAAA,GAAA,GAAA,EAAA,IAAA,EAAA,MAAA,GAAA,GAAA,EAAA,MAAA,IAAA,OAAA,uBAAA,EAAA,KAAA,GAAA,GAAA,EAAA,IAAA,WAAA,GAAA,GAAA,GAAA,KAAA,EAAA,QAAA,SAAA,GAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,OAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,QAAA,EAAA,EAAA,EAAA,GAAA,MAAA,GAAA,GAAA,QAAA,IAAA,GAAA,GAAA,kBAAA,UAAA,QAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,EAAA,EAAA,GAAA,OAAA,KAAA,UAAA,SAAA,EAAA,ICKA,SAAA,GAAA,GAAA,GAAA,EAAA,CAWE,IAXF,mBAAO,IAAP,OAAA,IAAA,EAAA,GACA,mBAAA,IAAA,OAAA,GAAQ,MAAR,IAAA,EAAA,GACA,mBAAA,SAAA,OAAA,QAAQ,MAAR,IAAA,EAAA,QAFA,EAAA,MAAA,EAAA,EAAA,UAAA,OAMA,MAAA,IANA,GAAA,MAAA,EAAA,OAAA,EAAA,EAAA,QAAA,EAAA,IAAA,OAAA,QAAA,MAAA,EAAA,EAAA,QAAA,aAAA,OAAA,QAWkB,kBAAN,GAXZ,KAAA,IAAA,OAAA,4HAAA,GAAA,QAAA,IAAA,KAAA,KAAA,mBAAA,MAAA,KAAA,mBAAA,QAAA,gBAAA,WAAA,SAAA,EAAA,GAAA,EAAA,QAAA,EAAA,eAAA,GAAA,SAAA,EAAA,GCLA,GAAA,GAAA,EAAA,EAAA,EAAA,CAAA,GAAY,EAAQ,aAApB,EACO,EAAU,KADjB,EAEI,EAAK,EAFT,EAGK,EAAK,kBAHV,EAAA,WA6Ee,QAAA,GAAC,GACZ,KAAC,QAAU,EAAE,QAAO,KAAU,KAAC,QAAS,GA5D1C,MAAA,GAAA,UAAA,SAME,eAAgB,KAOhB,aAAa,EAIb,aAAa,EAIb,WAIA,OAAQ,SAWR,MACE,OAAQ,eACR,KAAM,mBACN,OAAQ,mBACR,QAAS,mBACT,OAAQ,YAzCZ,EAAA,UA0EA,OAAQ,SAAC,GAAD,MACN,MAAK,YAAY,SAAU,IA3E7B,EAAA,UAyFA,OAAQ,SAAC,GAAD,MACN,MAAK,YAAY,SAAU,IA1F7B,EAAA,UAwGA,UAAQ,SAAC,GAAD,MACN,MAAK,YAAY,UAAW,IAzG9B,EAAA,UA8GA,MAAO,SAAC,GACN,GAAA,EAQA,OARA,GAAM,EAAE,WACR,KAAK,YAAY,SAAU,GAC1B,KAAK,SAAC,GACL,GAAA,EAAA,OAAA,GAAO,EAAI,WACX,GAAW,KACX,EAAI,QAAQ,EAAM,KACnB,KAAK,WAAA,MACJ,GAAI,OAAO,MAAM,EAAK,aACjB,EAAI,WAvHb,EAAA,UAmIA,UAAW,SAAC,EAAK,GAAN,MACT,MAAK,QAAQ,QAAQ,GAAO,GApI9B,EAAA,UAuJA,YAAa,SAAC,EAAQ,GACpB,GAAA,GAAA,EAAA,EAAA,CAAA,OAAA,GAAK,GAAO,EAAI,GAChB,EAAM,KAAK,QAAQ,EAAQ,GAC3B,EAAU,KAAK,mBAAmB,EAAQ,GAE1C,EAAU,EAAE,KAAK,EAAK,GAItB,EAAQ,IAAM,EACd,EAAQ,QAAU,EAClB,GAlKF,EAAA,UA2KA,mBAAoB,SAAC,EAAQ,GAC3B,GAAA,GAAA,EAAA,CAeA,OAfA,GAAS,KAAK,WAAW,GAEzB,GACE,KAAM,EACN,SAAU,OACV,MAAO,KAAK,SACZ,QAAS,KAAK,QAAQ,UAIrB,KAAC,QAAQ,aAA2B,QAAX,GAAkB,WAAlB,IAC1B,EAAK,QAAU,EAAE,OAAO,EAAK,SAAU,yBAA0B,IACjE,EAAK,KAAO,QAGD,WAAV,EACD,EAAO,EAAE,OAAO,GAAM,KAAM,KAM3B,MAAA,KAAA,QAAA,iBACD,EAAK,mBAAmB,oNAMxB,EAAE,OAAO,EAAK,KAAC,QAAQ,iBAEzB,EAAO,GAAO,KAAK,UAAU,GAK1B,KAAC,QAAQ,aACV,EAAK,MAAQ,KAAM,GAChB,KAAC,QAAQ,cACV,EAAK,KAAK,QAAU,GACf,GAET,EAAO,EAAE,OAAO,GACd,KAAM,EACN,YAAa,sCAxNjB,EAAA,UA0OA,QAAS,SAAC,EAAQ,GAChB,GAAA,EAAA,OAAA,GAAS,MAAA,KAAA,QAAA,OAAsB,KAAC,QAAQ,OAAY,GACpD,GAAO,KAAC,QAAQ,KAAK,GAGrB,EAAM,EAAI,QAAQ,QAAY,MAAA,EAAS,IAAM,EAAQ,IAErD,EAAM,EAAI,QAAQ,MAAU,MAAA,EAAS,EAAQ,KAjP/C,EAAA,UAgQA,WAAY,SAAC,GACX,GAAA,EAAA,OAAA,IACE,OAAQ,OACR,KAAM,MACN,OAAQ,MACR,QAAS,SACT,OAAQ,OAEV,EAAM,IAxQR,EAAA,UAgRA,SAAU,SAAC,GACT,GAAA,GAAA,CAUA,QAVA,EAAU,EAAI,QACd,EAAU,EAAG,uBAAyB,EAAS,EAAG,oBAEhC,WAAf,EAAI,QACL,EAAU,EAAG,uDACQ,SAAf,EAAI,SAAqB,EAAK,MACpC,EAAU,EAAG,uBACH,EACA,EAAG,oCAER,EAAI,QAAX,IACO,KACH,EAAU,EAAG,iCACH,EACA,EAAG,mBAHV,MADP,KAKO,KACH,EAAU,EAAG,sDADV,MALP,KAOO,KACH,EAAU,EAAG,wDAlBjB,MAoBA,GAAU,iBAAiB,EAAS,EAAU,aAAa,OAE3D,QAAQ,MAAM,EAAG,wBAA0B,KAAG,EAAI,OAAQ,OAvS5D,KAlBF,EA2TU,OAAO,SAAS,QAAS,GA3TnC,EA6TO,QAAU,YA7TjB,IAAA","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","# In order to build portable extension bundles that can be used with AMD and\n# script concatenation plugins are built with this module as 'annotator'.\n\n# Annotator will export itself globally when the built UMD modules are used in\n# a legacy environment of simple script concatenation.\nself = self if self?\nself ?= global if global?\nself ?= window if window?\nAnnotator = self?.Annotator\n\n# In a pure AMD environment, Annotator may not be exported globally.\nAnnotator ?= if self?.define?.amd then self?.require('annotator')\n\n# If we haven't successfully loaded Annotator by this point, there's no point in\n# going on to load the plugin, so throw a fatal error.\nif typeof Annotator isnt 'function'\n  throw new Error(\"Could not find Annotator! In a webpage context, please ensure\n                   that the Annotator script tag is loaded before any plugins.\")\n\n# Note: when working in a CommonJS environment and bundling requirements into\n# applications then require calls should refer to modules from the npm lib\n# directory of annotator package and avoid this altogether.\nmodule.exports = Annotator\n","Annotator = require('annotator')\nUtil = Annotator.Util\n$ = Util.$\n_t = Util.TranslationString\n\n\n# Public: The Store plugin can be used to persist annotations to a database\n# running on your server. It has a simple customisable interface that can be\n# implemented with any web framework. It works by listening to events published\n# by the Annotator and making appropriate requests to the server depending on\n# the event.\n#\n# The store handles five distinct actions \"read\", \"search\", \"create\", \"update\"\n# and \"destroy\". The requests made can be customised with options when the\n# plugin is added to the Annotator.\nclass Store\n\n  # User customisable options available.\n  options:\n\n    # Custom meta data that will be attached to every annotation that is sent\n    # to the server. This _will_ override previous values.\n    #\n    # @slatedForDeprecation 2.1.0\n    annotationData: null\n\n    # Should the plugin emulate HTTP methods like PUT and DELETE for\n    # interaction with legacy web servers? Setting this to `true` will fake\n    # HTTP `PUT` and `DELETE` requests with an HTTP `POST`, and will set the\n    # request header `X-HTTP-Method-Override` with the name of the desired\n    # method.\n    emulateHTTP: false\n\n    # Should the plugin emulate JSON POST/PUT payloads by sending its requests\n    # as application/x-www-form-urlencoded with a single key, \"json\"\n    emulateJSON: false\n\n    # A set of custom headers that will be sent with every request. See also the\n    # setHeader method.\n    headers: {}\n\n    # This is the API endpoint. If the server supports Cross Origin Resource\n    # Sharing (CORS) a full URL can be used here.\n    prefix: '/store'\n\n    # The server URLs for each available action. These URLs can be anything but\n    # must respond to the appropraite HTTP method. The token \":id\" can be used\n    # anywhere in the URL and will be replaced with the annotation id.\n    #\n    # read:    GET\n    # create:  POST\n    # update:  PUT\n    # destroy: DELETE\n    # search:  GET\n    urls:\n      create: '/annotations'\n      read: '/annotations/:id'\n      update: '/annotations/:id'\n      destroy: '/annotations/:id'\n      search: '/search'\n\n  # Public: The contsructor initailases the Store instance. It requires the\n  # Annotator#element and an Object of options.\n  #\n  # element - This must be the Annotator#element in order to listen for events.\n  # options - An Object of key/value user options.\n  #\n  # Examples\n  #\n  #   store = new Annotator.Plugin.Store(Annotator.element, {\n  #     prefix: 'http://annotateit.org',\n  #     annotationData: {\n  #       uri: window.location.href\n  #     }\n  #   })\n  #\n  # Returns a new instance of Store.\n  constructor: (options) ->\n    @options = $.extend(true, {}, @options, options)\n\n  # Public: Callback method for annotationCreated event. Receives an annotation\n  # and sends a POST request to the sever using the URI for the \"create\" action.\n  #\n  # annotation - An annotation Object that was created.\n  #\n  # Examples\n  #\n  #   store.annotationCreated({text: \"my new annotation comment\"})\n  #   # => Results in an HTTP POST request to the server containing the\n  #   #    annotation as serialised JSON.\n  #\n  # Returns a jqXHR object.\n  create: (annotation) ->\n    this._apiRequest('create', annotation)\n\n  # Public: Callback method for annotationUpdated event. Receives an annotation\n  # and sends a PUT request to the sever using the URI for the \"update\" action.\n  #\n  # annotation - An annotation Object that was updated.\n  #\n  # Examples\n  #\n  #   store.annotationUpdated({id: \"blah\", text: \"updated annotation comment\"})\n  #   # => Results in an HTTP PUT request to the server containing the\n  #   #    annotation as serialised JSON.\n  #\n  # Returns a jqXHR object.\n  update: (annotation) ->\n    this._apiRequest('update', annotation)\n\n  # Public: Callback method for annotationDeleted event. Receives an annotation\n  # and sends a DELETE request to the server using the URI for the destroy\n  # action.\n  #\n  # annotation - An annotation Object that was deleted.\n  #\n  # Examples\n  #\n  #   store.annotationDeleted({text: \"my new annotation comment\"})\n  #   # => Results in an HTTP DELETE request to the server.\n  #\n  # Returns a jqXHR object.\n  delete: (annotation) ->\n    this._apiRequest('destroy', annotation)\n\n  # Public: Searches for annotations matching the specified query.\n  #\n  # Returns a Promise resolving to the query results and query metadata.\n  query: (queryObj) ->\n    dfd = $.Deferred()\n    this._apiRequest('search', queryObj)\n    .done (obj) ->\n      rows = obj.rows\n      delete obj.rows\n      dfd.resolve(rows, obj)\n    .fail ->\n      dfd.reject.apply(dfd, arguments)\n    return dfd.promise()\n\n  # Public: Set a custom HTTP header to be sent with every request.\n  #\n  # key   - The header name.\n  # value - The header value.\n  #\n  # Examples:\n  #\n  #   store.setHeader('X-My-Custom-Header', 'MyCustomValue')\n  #\n  # Returns nothing.\n  setHeader: (key, value) ->\n    this.options.headers[key] = value\n\n  # Callback method for Store#loadAnnotationsFromSearch(). Processes the data\n  # returned from the server (a JSON array of annotation Objects) and updates\n  # the registry as well as loading them into the Annotator.\n  # Returns the jQuery XMLHttpRequest wrapper enabling additional callbacks to\n  # be applied as well as custom error handling.\n  #\n  # action    - The action String eg. \"read\", \"search\", \"create\", \"update\"\n  #             or \"destory\".\n  # obj       - The data to be sent, either annotation object or query string.\n  # onSuccess - A callback Function to call on successful request.\n  #\n  # Examples:\n  #\n  #   store._apiRequest('read', {id: 4}, (data) -> console.log(data))\n  #   # => Outputs the annotation returned from the server.\n  #\n  # Returns XMLHttpRequest object.\n  _apiRequest: (action, obj) ->\n    id = obj && obj.id\n    url = this._urlFor(action, id)\n    options = this._apiRequestOptions(action, obj)\n\n    request = $.ajax(url, options)\n\n    # Append the id and action to the request object\n    # for use in the error callback.\n    request._id = id\n    request._action = action\n    request\n\n  # Builds an options object suitable for use in a jQuery.ajax() call.\n  #\n  # action    - The action String eg. \"read\", \"search\", \"create\", \"update\"\n  #             or \"destroy\".\n  # obj       - The data to be sent, either annotation object or query string.\n  #\n  # Returns Object literal of $.ajax() options.\n  _apiRequestOptions: (action, obj) ->\n    method = this._methodFor(action)\n\n    opts =\n      type: method,\n      dataType: \"json\",\n      error: this._onError,\n      headers: this.options.headers\n\n    # If emulateHTTP is enabled, we send a POST and put the real method in an\n    # HTTP request header.\n    if @options.emulateHTTP and method in ['PUT', 'DELETE']\n      opts.headers = $.extend(opts.headers, {'X-HTTP-Method-Override': method})\n      opts.type = 'POST'\n\n    # Don't JSONify obj if making search request.\n    if action is \"search\"\n      opts = $.extend(opts, data: obj)\n      return opts\n\n    # Add annotationData to object, if specified\n    #\n    # @slatedForDeprecation 2.1.0\n    if @options.annotationData?\n      Util.deprecationWarning(\"Use of the annotationData option to the Store\n                               plugin is deprecated and will be removed in a\n                               future version. Please use hooks to\n                               beforeAnnotationCreated and\n                               beforeAnnotationUpdated to replicate this\n                               behaviour.\")\n      $.extend(obj, @options.annotationData)\n\n    data = obj && JSON.stringify(obj)\n\n    # If emulateJSON is enabled, we send a form request (the correct\n    # contentType will be set automatically by jQuery), and put the\n    # JSON-encoded payload in the \"json\" key.\n    if @options.emulateJSON\n      opts.data = {json: data}\n      if @options.emulateHTTP\n        opts.data._method = method\n      return opts\n\n    opts = $.extend(opts, {\n      data: data\n      contentType: \"application/json; charset=utf-8\"\n    })\n    return opts\n\n  # Builds the appropriate URL from the options for the action provided.\n  #\n  # action - The action String.\n  # id     - The annotation id as a String or Number.\n  #\n  # Examples\n  #\n  #   store._urlFor('update', 34)\n  #   # => Returns \"/store/annotations/34\"\n  #\n  #   store._urlFor('search')\n  #   # => Returns \"/store/search\"\n  #\n  # Returns URL String.\n  _urlFor: (action, id) ->\n    url = if @options.prefix? then @options.prefix else ''\n    url += @options.urls[action]\n    # If there's a '/:id' in the URL, either fill in the ID or remove the\n    # slash:\n    url = url.replace(/\\/:id/, if id? then '/' + id else '')\n    # If there's a bare ':id' in the URL, then substitute directly:\n    url = url.replace(/:id/, if id? then id else '')\n\n    url\n\n  # Maps an action to an HTTP method.\n  #\n  # action - The action String.\n  #\n  # Examples\n  #\n  #   store._methodFor('read')    # => \"GET\"\n  #   store._methodFor('update')  # => \"PUT\"\n  #   store._methodFor('destroy') # => \"DELETE\"\n  #\n  # Returns HTTP method String.\n  _methodFor: (action) ->\n    table =\n      create: 'POST'\n      read: 'GET'\n      update: 'PUT'\n      destroy: 'DELETE'\n      search: 'GET'\n\n    table[action]\n\n  # jQuery.ajax() callback. Displays an error notification to the user if\n  # the request failed.\n  #\n  # xhr - The jXMLHttpRequest object.\n  #\n  # Returns nothing.\n  _onError: (xhr) ->\n    action  = xhr._action\n    message = _t(\"Sorry we could not \") + action + _t(\" this annotation\")\n\n    if xhr._action == 'search'\n      message = _t(\"Sorry we could not search the store for annotations\")\n    else if xhr._action == 'read' && !xhr._id\n      message = _t(\"Sorry we could not \") +\n                action +\n                _t(\" the annotations from the store\")\n\n    switch xhr.status\n      when 401\n        message = _t(\"Sorry you are not allowed to \") +\n                  action +\n                  _t(\" this annotation\")\n      when 404\n        message = _t(\"Sorry we could not connect to the annotations store\")\n      when 500\n        message = _t(\"Sorry something went wrong with the annotation store\")\n\n    Annotator.showNotification message, Annotator.Notification.ERROR\n\n    console.error _t(\"API request failed:\") + \" '#{xhr.status}'\"\n\nAnnotator.Plugin.register('Store', Store)\n\nmodule.exports = Store\n"]}